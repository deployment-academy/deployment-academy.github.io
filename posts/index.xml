<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Deployment</title><link>https://deployment.properties/posts/</link><description>Recent content in Posts on Deployment</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 18 Sep 2021 13:48:06 -0400</lastBuildDate><atom:link href="https://deployment.properties/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>GKE Dataplane V2 and Network Policies in Practice</title><link>https://deployment.properties/posts/devsecops/gke-dataplane-v2-network-policies/</link><pubDate>Sat, 18 Sep 2021 13:48:06 -0400</pubDate><guid>https://deployment.properties/posts/devsecops/gke-dataplane-v2-network-policies/</guid><description>&lt;p>In this tutorial, we are going to play with the &lt;a href="https://cloud.google.com/kubernetes-engine/docs/concepts/dataplane-v2">Google Kubernetes Engine Dataplane V2&lt;/a> and check how we can use it along with &lt;a href="https://kubernetes.io/docs/concepts/services-networking/network-policies/">Kubernetes Network Policies&lt;/a> to limit traffic to Pods and to obtain real-time visibility on cluster network activity.&lt;/p>
&lt;p>Dataplane V2 is a &lt;a href="https://cloud.google.com/blog/products/containers-kubernetes/bringing-ebpf-and-cilium-to-google-kubernetes-engine">recent feature in GKE&lt;/a>, with GA starting on version 1.20.6-gke.700 as of May 10, 2021. It uses &lt;a href="https://cilium.io/">Cilium&lt;/a> to process network packets in-kernel using Kubernetes-specific metadata without relying on the kube-proxy and iptables for service routing, resulting in performance improvements. Dataplane V2 brings some exciting features for cluster operations and security, such as:&lt;/p>
&lt;ul>
&lt;li>Built-in Network Policies enforcement without the need of Calico and;&lt;/li>
&lt;li>Real-time visibility, enabling cluster networking troubleshooting, auditing, and alerting.&lt;/li>
&lt;/ul></description></item><item><title>Vulnerable Dependency Management: The Invisible Enemy</title><link>https://deployment.properties/posts/devsecops/vulnerable-dependency-management/</link><pubDate>Sun, 22 Aug 2021 12:52:20 -0400</pubDate><guid>https://deployment.properties/posts/devsecops/vulnerable-dependency-management/</guid><description>&lt;p>Let&amp;rsquo;s talk about something that most developers and engineering teams don&amp;rsquo;t pay the necessary attention to. Do you have a process to update your application dependencies? How likely is it that your application could be compromised because of a vulnerable dependency?&lt;/p></description></item><item><title>Create a static website with Hugo, GitHub Pages and Actions (in minutes)</title><link>https://deployment.properties/posts/hugo/hugo-gh-pages-n-actions/</link><pubDate>Sun, 15 Aug 2021 22:55:44 -0400</pubDate><guid>https://deployment.properties/posts/hugo/hugo-gh-pages-n-actions/</guid><description>&lt;p>In this tutorial, we are going to get a static website up and running with Hugo.
We will deploy the site using GitHub Pages and make sure new changes are
automatically published using GitHub Actions.&lt;/p></description></item><item><title>HashiCorp Vault AWS Auth with Amazon EKS and IAM Roles for Service Accounts</title><link>https://deployment.properties/posts/devsecops/vault-eks-irsa/</link><pubDate>Sun, 23 May 2021 00:00:00 +0000</pubDate><guid>https://deployment.properties/posts/devsecops/vault-eks-irsa/</guid><description>&lt;p>In this tutorial, we are going to configure and explore the &lt;a href="https://www.vaultproject.io/docs/auth/aws">HashiCorp Vault AWS Auth method&lt;/a> with &lt;a href="https://aws.amazon.com/eks">Amazon EKS&lt;/a>. We will start performing the Vault authentication using the EC2 instances (Kubernetes nodes) identity and later we will use a Kubernetes service account to impersonate an AWS IAM Role and have more fine-grained control at the Pod level.&lt;/p></description></item><item><title>Google Cloud Endpoints in GKE with Container-native Load Balancing</title><link>https://deployment.properties/posts/devsecops/gke-cloud-endpoints/</link><pubDate>Mon, 08 Mar 2021 00:00:00 +0000</pubDate><guid>https://deployment.properties/posts/devsecops/gke-cloud-endpoints/</guid><description>&lt;p>In the source code for this tutorial, we extend the &lt;a href="https://cloud.google.com/endpoints/docs/openapi/get-started-kubernetes-engine">Getting started with Cloud Endpoints for GKE with ESP&lt;/a> documentation guide to provide an example of how to configure HTTPS between the LB and the ESP.&lt;/p></description></item><item><title>Workload Identity in Practice</title><link>https://deployment.properties/posts/devsecops/workload-identity-getting-started/</link><pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate><guid>https://deployment.properties/posts/devsecops/workload-identity-getting-started/</guid><description>&lt;p>In this tutorial, we&amp;rsquo;re going to go through the &lt;a href="https://cloud.google.com/blog/products/containers-kubernetes/introducing-workload-identity-better-authentication-for-your-gke-applications">Workload Identity&lt;/a> feature and see how it helps to improve the way we manage access to Google Services and APIs from applications running in &lt;a href="https://cloud.google.com/kubernetes-engine">Google Kubernetes Engine (GKE)&lt;/a>.&lt;/p>
&lt;p>Workload Identity is the recommended way to access Google Cloud APIs from within GKE due to its improved security properties and manageability. With Workload Identity you can control access to APIs using &lt;a href="https://cloud.google.com/iam/docs/service-accounts">Google service accounts&lt;/a> and &lt;a href="https://cloud.google.com/iam/docs/understanding-roles">IAM roles&lt;/a> without deploying static service account JSON keys to Pods and without relying on the node&amp;rsquo;s service account.&lt;/p></description></item></channel></rss>